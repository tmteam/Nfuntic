using System;
using System.Collections.Generic;
using System.Text;
using NUnit.Framework;

namespace nfun.ti4.tests
{
    public class PrimitiveSolvingTests
    {
        [Test(Description = "y = if a: 1 else 0")]
        public void SolvingSimpleCaseWithIfs()
        {
            //node |6 5  2 1  0  4   3 
            //expr |y = if a: 1 else 0;

            _ti.SetStrict(0, TiType.Int32);
            _ti.SetVar(1, "a");
            _ti.SetStrict(1, TiType.Bool);
            _ti.Unite(2, 0);
            _ti.SetStrict(3, TiType.Int32);
            _ti.Unite(4, 2);
            _ti.Unite(5, 2);
            _ti.Unite(6, 5);
            _ti.SetVar(6, "y");
            var result = _ti.Solve();

            Assert.AreEqual(0, result.GenericsCount);
            Assert.AreEqual(TiType.Bool, result.GetVarType("a"));
            Assert.AreEqual(TiType.Int32, result.GetVarType("y"));

        }


        [Test(Description = "y=if a:x; else z+1;")]
        public void SolvingCaseWithIfs()
        {
            //node |5  6    1  0        2 4 3
            //expr |y = if (a) x; else (z + 1);

            _ti.SetVar(0, "x");
            _ti.SetVar(1, "a");
            _ti.SetStrict(1, TiType.Bool);
            _ti.SetVar(2, "z");
            _ti.SetStrict(2, TiType.Int32);
            _ti.SetStrict(3, TiType.Int32);
            _ti.SetStrict(4, TiType.Int32);
            _ti.Unite(0, 4);
            _ti.Unite(0, 6);
            _ti.SetVar(5, "y");
            _ti.Unite(5, 6);

            var result = _ti.Solve();
            Assert.Multiple(() =>
            {
                Assert.AreEqual(0, result.GenericsCount);
                Assert.AreEqual(TiType.Bool, result.GetVarType("a"), "a");
                Assert.AreEqual(TiType.Int32, result.GetVarType("x"), "x");
                Assert.AreEqual(TiType.Int32, result.GetVarType("z"), "z");
                Assert.AreEqual(TiType.Int32, result.GetVarType("y"), "y");
            });
        }

        [Test(Description = "y = if (a) x else z ")]
        public void CleanGenericOnIfs()
        {
            //node |6 5  2    1   0  4   3 
            //expr |y = if (true) x else z 

            _ti.SetVar(0, "x");
            _ti.SetStrict(1, TiType.Bool);
            _ti.Unite(2, 0);
            _ti.SetVar(3, "z");
            _ti.Unite(4, 3);
            _ti.Unite(4, 2);
            _ti.Unite(5, 4);
            _ti.Unite(6, 5);
            _ti.SetVar(6, "y");

            var result = _ti.Solve();

            Assert.AreEqual(1, result.GenericsCount);
            Assert.AreEqual(TiType.Generic(0), result.GetVarType("x"));
            Assert.AreEqual(TiType.Generic(0), result.GetVarType("z"));
            Assert.AreEqual(TiType.Generic(0), result.GetVarType("y"));
        }
        


        [Test]
        public void LimitCall_ComplexEquations_TypesSolved()
        {
            // 3   0 2 1  7   4 6  5  11  8 10 9
            // r = x + y; i = y << 2; x = 3 /  2
            solver.SetVar(0, "x");
            solver.SetVar(1, "y");
            solver.SetArithmeticalOp(2, 0, 1).AssertSuccesfully();
            solver.SetDefenition("r", 3, 2);

            solver.SetVar(4, "y");
            solver.SetConst(5, TiType.Int32);
            solver.SetBitShiftOperator(6, 4, 5);
            solver.SetDefenition("i", 7, 6);

            solver.SetConst(8, TiType.Int32);
            solver.SetConst(9, TiType.Int32);
            solver.SetCall(new CallDefinition(TiType.Real, new[] { 10, 8, 9 }));
            solver.SetDefenition("x", 11, 10);

            var solvation = solver.Solve();

            Assert.AreEqual(TiType.Real, solvation.GetVarType("x"));
            Assert.AreEqual(TiType.Real, solvation.GetVarType("r"));
            Assert.AreEqual(TiType.Int32, solvation.GetVarType("y"));
        }

        [Test]
        public void TwoIntTypes_ResultTypeIsInteger()
        {
            //  1   0  2 4 3
            //  x = 1; x<<3 
            solver.SetConst(0, TiType.Int32);
            solver.SetDefenition("x", 1, 0);
            solver.SetBitShiftOperator(4, 2, 3).AssertSuccesfully();
            Assert.AreEqual(TiType.Int32, solver.Solve().GetVarType("x"));
        }

        [Test]
        public void ConstantLcaIf_ResultTypeIsInteger()
        {
            //  4   3    1   0      2
            //  x = if(true) 1 else 2 
            solver.SetConst(0, TiType.Int32);
            solver.SetConst(1, TiType.Bool);
            solver.SetConst(2, TiType.Int32);
            solver.ApplyLcaIf(3, new[] { 1 }, new[] { 0, 2 });
            solver.SetDefenition("x", 4, 3);
            Assert.AreEqual(TiType.Int32, solver.Solve().GetVarType("x"));
        }
        [Test]
        public void ConstantLcaOneOfThemIf_ResultTypeIsInteger()
        {
            //  4   3    1   0      2
            //  x = if(true) 1 else 2 
            solver.SetConst(0, TiType.Int32);
            solver.SetConst(1, TiType.Bool);
            solver.SetConst(2, TiType.Int32);
            solver.ApplyLcaIf(3, new[] { 1 }, new[] { 0, 2 });
            solver.SetDefenition("x", 4, 3);
            Assert.AreEqual(TiType.Int32, solver.Solve().GetVarType("x"));
        }

        [Test]
        public void SummReducecByBitShift_AllTypesAreInt()
        {
            //  0 2 1  4 3
            //( x + y )<<3
            solver.SetVar(0, "x");
            solver.SetVar(1, "y");
            solver.SetArithmeticalOp(2, 0, 1);
            solver.SetBitShiftOperator(4, 2, 3).AssertSuccesfully();
            var solvation = solver.Solve();

            Assert.AreEqual(TiType.Int32, solvation.GetVarType("x"));
            Assert.AreEqual(TiType.Int32, solvation.GetVarType("y"));
        }

       


        [Test]
        public void UpcastArgTypes_BothTypesLimitedAfter_EquationSolved()
        {
            // 3      2    0,1    5   4      9   6 8  7     
            // y = sumReal(a,b);  a = 1:int; b = a << 2
            solver.SetVar(0, "a");
            solver.SetVar(1, "b");
            solver.SetCall(new CallDefinition(TiType.Real, new[] { 2, 0, 1 }));
            solver.SetDefenition("y", 3, 2);
            solver.SetConst(4, TiType.Int32);
            solver.SetDefenition("a", 5, 4).AssertSuccesfully();
            solver.SetVar(6, "a");
            solver.SetConst(7, TiType.Int32);
            solver.SetBitShiftOperator(8, 6, 7).AssertSuccesfully();
            solver.SetDefenition("b", 9, 8).AssertSuccesfully();

            var solvation = solver.Solve();
            Assert.AreEqual(TiType.Real, solvation.GetVarType("y"));
            Assert.AreEqual(TiType.Int32, solvation.GetVarType("a"));
            Assert.AreEqual(TiType.Int32, solvation.GetVarType("b"));
            Assert.AreEqual(0, solvation.GenericsCount);
        }

        

      
        [Test]
        public void ComplexEquations_TypesSolved()
        {
            // 3   0 2 1  7   4 6  5  11  8 10 9
            // r = x + y; i = y << 2; x = 3 /  2
            solver.SetVar(0, "x");
            solver.SetVar(1, "y");
            solver.SetArithmeticalOp(2, 0, 1);
            solver.SetDefenition("r", 3, 2);

            solver.SetVar(4, "y");
            solver.SetConst(5, TiType.Int32);
            solver.SetBitShiftOperator(6, 4, 5);
            solver.SetDefenition("i", 7, 6);

            solver.SetConst(8, TiType.Int32);
            solver.SetConst(9, TiType.Int32);
            solver.SetCall(new CallDefinition(TiType.Real, new[] { 10, 8, 9 }));
            solver.SetDefenition("x", 11, 10);

            var solvation = solver.Solve();

            Assert.AreEqual(TiType.Real, solvation.GetVarType("x"));
            Assert.AreEqual(TiType.Real, solvation.GetVarType("r"));
            Assert.AreEqual(TiType.Int32, solvation.GetVarType("y"));
        }


        [Test]
        public void If_withOneIntAndOneVar_equalReal()
        {
            //4    3     1   0      2
            //y  = if (true) 1 else x
            solver.SetConst(0, TiType.Int32);
            solver.SetConst(1, TiType.Bool);
            solver.SetVar(2, "x");
            Assert.IsTrue(solver.ApplyLcaIf(3, new[] { 1 }, new[] { 0, 2 }));
            solver.SetDefenition("y", 4, 3).AssertSuccesfully();

            var solvation = solver.Solve();
            Assert.IsTrue(solvation.IsSolved);

            Assert.AreEqual(0, solvation.GenericsCount);
            Assert.AreEqual(TiType.Int32, solvation.GetVarType("y"));
            Assert.AreEqual(TiType.Int32, solvation.GetVarType("x"));
        }

        [Test]
        public void If_withMultipleAncestorRules_EquationSolved()
        {
            //4     3     1   0      2  6    5   10    7 9 8
            //y1  = if (true) 1 else x; y2 = y1; y3 = y1 * 2
            solver.SetConst(0, TiType.Int32);
            solver.SetConst(1, TiType.Bool);
            solver.SetVar(2, "x");
            Assert.IsTrue(solver.ApplyLcaIf(3, new[] { 1 }, new[] { 0, 2 }));
            solver.SetVar(5, "y1");
            solver.SetDefenition("y2", 6, 5).AssertSuccesfully();
            solver.SetVar(7, "y1");
            solver.SetConst(8, TiType.Int32);
            solver.SetArithmeticalOp(9, 7, 8);
            solver.SetDefenition("y3", 10, 9).AssertSuccesfully();


            var solvation = solver.Solve();
            Assert.IsTrue(solvation.IsSolved);

            Assert.AreEqual(0, solvation.GenericsCount);
            Assert.AreEqual(TiType.Real, solvation.GetVarType("y1"));
            Assert.AreEqual(TiType.Real, solvation.GetVarType("y2"));
            Assert.AreEqual(TiType.Real, solvation.GetVarType("y3"));

            Assert.AreEqual(TiType.Int32, solvation.GetVarType("x"));
        }

        [Test]
        public void MultipleAncestors_EquationSolved()
        {
            //1     0     3    2   7    4 6 5
            //y1  = y0;  y2 = y1; y3 = y2 * 2
            solver.SetVar(0, "y0");
            solver.SetDefenition("y1", 1, 0);

            solver.SetVar(2, "y1");
            solver.SetDefenition("y2", 3, 2);

            solver.SetVar(4, "y2");
            solver.SetConst(6, TiType.Int32);
            solver.SetArithmeticalOp(6, 4, 5);
            solver.SetDefenition("y3", 7, 6);

            var solvation = solver.Solve();
            Assert.IsTrue(solvation.IsSolved);

            Assert.AreEqual(0, solvation.GenericsCount);
            Assert.AreEqual(TiType.Int32, solvation.GetVarType("y1"));
            Assert.AreEqual(TiType.Int32, solvation.GetVarType("y2"));
            Assert.AreEqual(TiType.Int32, solvation.GetVarType("y3"));
        }

        [Test]
        public void ReverseMultipleAncestors_EquationSolved()
        {
            //1     0     3    2   7    4 6 5
            //y1  = y0;  y2 = y1; y3 = y0 * 2
            solver.SetVar(0, "y0");
            solver.SetDefenition("y1", 1, 0);

            solver.SetVar(2, "y1");
            solver.SetDefenition("y2", 3, 2);

            solver.SetVar(4, "y0");
            solver.SetConst(6, TiType.Int32);
            solver.SetArithmeticalOp(6, 4, 5);
            solver.SetDefenition("y3", 7, 6);

            var solvation = solver.Solve();
            Assert.IsTrue(solvation.IsSolved);

            Assert.AreEqual(0, solvation.GenericsCount);
            Assert.AreEqual(TiType.Int32, solvation.GetVarType("y1"));
            Assert.AreEqual(TiType.Int32, solvation.GetVarType("y2"));
            Assert.AreEqual(TiType.Int32, solvation.GetVarType("y3"));
        }
        [Test]
        public void TypeSpecified_PutHighterType_EquationSOlved()
        {
            //         1    0  
            //a:real;  a = 1:int32

            solver.SetVarType("a", TiType.Real);

            solver.SetConst(0, TiType.Int32);
            solver.SetDefenition("a", 1, 0).AssertSuccesfully();
            var solvation = solver.Solve();
            Assert.AreEqual(TiType.Real, solvation.GetVarType("a"));
        }

        [Test]
        public void TypeLimitSet_ThanChangedToLower_LowerLimitAccepted()
        {
            //1   0       3   2
            //a = 1:int;  a = 1.0:int64

            solver.SetConst(0, TiType.Int32);
            solver.SetDefenition("a", 1, 0).AssertSuccesfully();
            solver.SetConst(2, TiType.Int64);

            solver.SetDefenition("a", 3, 2).AssertSuccesfully();

            var solvation = solver.Solve();
            Assert.IsTrue(solvation.IsSolved);

            Assert.AreEqual(TiType.Int64, solvation.GetVarType("a"));
        }
        [Test]
        public void TypeLimitSet_ThanChangedToHigher_LowerLimitAccepted()
        {
            //1   0          3   2
            //a = 1:int64;  a = 1.0:int32

            solver.SetConst(0, TiType.Int64);
            solver.SetDefenition("a", 1, 0).AssertSuccesfully();
            solver.SetConst(2, TiType.Int32);

            solver.SetDefenition("a", 3, 2).AssertSuccesfully();

            var solvation = solver.Solve();
            Assert.IsTrue(solvation.IsSolved);

            Assert.AreEqual(TiType.Int64, solvation.GetVarType("a"));
        }

        [Test]
        public void ArgTypesAreSpecified_OutputTypeIsCorrect()
        {
            //          3   1 2 0
            //a,b:long; y = a + b #y:long
            solver.SetVarType("a", TiType.Int64);
            solver.SetVarType("b", TiType.Int64);

            solver.SetVar(0, "a");
            solver.SetVar(1, "b");
            solver.SetArithmeticalOp(2, 1, 0);
            solver.SetDefenition("y", 3, 2);
            var solvation = solver.Solve();
            Assert.IsTrue(solvation.IsSolved);

            Assert.AreEqual(TiType.Int64, solvation.GetVarType("y"));
        }

        [Test]
        public void OutEqualsToItself_SingleGenericFound()
        {
            //1   0
            //y = y
            solver.SetVar(0, "y");
            solver.SetDefenition("y", 1, 0);

            var res = solver.Solve();
            Assert.AreEqual(1, res.GenericsCount);
            Assert.AreEqual(TiType.Generic(0), res.GetVarType("y"));
        }
        [Test]
        public void OutEqualsToItself_TypeSpecified_EquationSolved()
        {
            //        1   0
            //y:bool; y = y
            solver.SetVarType("y", TiType.Bool);
            solver.SetVar(0, "y");
            solver.SetDefenition("y", 1, 0);

            var res = solver.Solve();
            Assert.AreEqual(0, res.GenericsCount);
            Assert.AreEqual(TiType.Bool, res.GetVarType("y"));
        }
        [Test]
        public void OutEqualsToItself_TypeLimitedAfter_EquationSolved()
        {
            // 1   0  3   2
            // y = y; y = 1;
            solver.SetVar(0, "y");
            solver.SetDefenition("y", 1, 0);
            solver.SetConst(2, TiType.Int32);
            solver.SetDefenition("y", 3, 2);

            var res = solver.Solve();
            Assert.AreEqual(0, res.GenericsCount);
            Assert.AreEqual(TiType.Int32, res.GetVarType("y"));
        }
        [Test]
        public void OutEqualsToItself_TypeLimitedBefore_EquationSolved()
        {
            // 1   0  3   2
            // y = 1; y = y; 
            solver.SetConst(0, TiType.Int32);
            solver.SetDefenition("y", 1, 0);

            solver.SetVar(2, "y");
            solver.SetDefenition("y", 3, 2);

            var res = solver.Solve();
            Assert.AreEqual(0, res.GenericsCount);
            Assert.AreEqual(TiType.Int32, res.GetVarType("y"));
        }

        [Test]
        public void CircularDependenciesWithEquation_SingleGenericFound()
        {
            //3   021  7   465   
            //a = b*c; b = c*a; 
            solver.SetVar(0, "b");
            solver.SetVar(1, "c");
            solver.SetArithmeticalOp(2, 0, 1);
            solver.SetDefenition("a", 3, 2);

            solver.SetVar(4, "c");
            solver.SetVar(5, "a");
            solver.SetArithmeticalOp(6, 4, 5);
            solver.SetDefenition("b", 4, 5);

            var res = solver.Solve();

            Assert.AreEqual(0, res.GenericsCount);
            Assert.AreEqual(TiType.Real, res.GetVarType("a"));
            Assert.AreEqual(TiType.Real, res.GetVarType("b"));
            Assert.AreEqual(TiType.Real, res.GetVarType("c"));
        }


        [Test]
        public void CircularDependencies_AllTypesSpecified_EquationSolved()
        {
            //1   0  3   2  5   4
            //a = b; b = c; c = a
            solver.SetVarType("a", TiType.Bool);
            solver.SetVarType("b", TiType.Bool);
            solver.SetVarType("c", TiType.Bool);

            solver.SetVar(0, "b");
            solver.SetDefenition("a", 1, 0);

            solver.SetVar(2, "c");
            solver.SetDefenition("a", 3, 2);

            solver.SetVar(4, "a");
            solver.SetDefenition("a", 5, 4);

            var res = solver.Solve();

            Assert.AreEqual(0, res.GenericsCount);
            Assert.AreEqual(TiType.Bool, res.GetVarType("a"));
            Assert.AreEqual(TiType.Bool, res.GetVarType("b"));
            Assert.AreEqual(TiType.Bool, res.GetVarType("c"));
        }

        [Test]
        public void CircularDependencies_SingleGenericFound()
        {
            //1   0  3   2  5   4
            //a = b; b = c; c = a
            solver.SetVar(0, "b");
            solver.SetDefenition("a", 1, 0);

            solver.SetVar(2, "c");
            solver.SetDefenition("a", 3, 2);

            solver.SetVar(4, "a");
            solver.SetDefenition("a", 5, 4);

            var res = solver.Solve();

            Assert.AreEqual(1, res.GenericsCount);
            Assert.AreEqual(TiType.Generic(0), res.GetVarType("a"));
            Assert.AreEqual(TiType.Generic(0), res.GetVarType("b"));
            Assert.AreEqual(TiType.Generic(0), res.GetVarType("c"));
        }

        [Test]
        public void OutDependsOnItself_Resolved()
        {
            //3   0 2 1
            //y = y + 2
            solver.SetVar(0, "y");
            solver.SetConst(1, TiType.Int32);
            solver.SetArithmeticalOp(2, 0, 1);

            solver.SetDefenition("y", 3, 2);

            var res = solver.Solve();
            Assert.AreEqual(0, res.GenericsCount);
            Assert.AreEqual(TiType.Real, res.GetVarType("y"));
        }

    }
}
